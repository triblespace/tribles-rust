<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Identifiers - Tribles Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guided tour of Trible Space and how to use the crate.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tribles Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="identifiers-for-distributed-systems"><a class="header" href="#identifiers-for-distributed-systems">Identifiers for Distributed Systems</a></h1>
<p>We found it useful to categorize identifiers along two axes:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Abstract</strong></th><th><strong>Semantic</strong></th></tr></thead><tbody>
<tr><td><strong>Intrinsic</strong></td><td>Hash, Signature, PubKey</td><td>embeddings</td></tr>
<tr><td><strong>Extrinsic</strong></td><td>UUID, UFOID, FUCID</td><td>names, DOI, URL</td></tr>
</tbody></table>
</div>
<h2 id="abstract-vs-semantic-identifiers"><a class="header" href="#abstract-vs-semantic-identifiers">Abstract vs. Semantic Identifiers</a></h2>
<ul>
<li>
<p><strong>Semantic Identifiers (e.g., human-readable names, URLs, embeddings)</strong>
These identifiers carry meaning and context about the entity they represent.
This can make them them useful for human users,
as they can convey information about the entity without requiring additional lookups.
For example, a URL can provide information about the location of a resource,
or a human readable name can provide information about the entity itself.
Embeddings are a special case of semantic identifiers,
as they represent the content of an entity in a way that can be compared to other entities.
They are also more likely to change over time, as the context of the entity changes.
This makes them less useful for identity, as they are not necessarily unique;
their strength is to aid interpretation rather than define persistence.
To avoid ambiguities and conflicts or the need for a central authority to manage them,
semantic identifiers should always be explicitly scoped to a context,
such as a namespace or system environment. This ensures that the
same name can coexist in different contexts without collision or confusion.
This scoping also addresses social challenges inherent in human-readable names:
different users may prefer different names for the same entity.
By allowing local names to reference persistent identifiers (extrinsic or intrinsic),
each user can adopt their preferred naming conventions while maintaining
a shared understanding of the underlying identity.</p>
</li>
<li>
<p><strong>Abstract Identifiers (e.g., UUIDs, UFOIDs, FUCIDs, hashes, signatures)</strong><br />
These identifiers provide abstract identity without imposing any semantic meaning or cultural connotations.
They can be generated cheaply and without coordination, relying on high entropy to make collisions
practically impossible, uniquely, globally, and persistently addressing an entity, regardless of its content or context.
Abstract identifiers, when used to reference entities in a system, provide a stable and unique identity that is
independent of the content or context of the entity. They are particularly useful in distributed systems, where
they can be used to address entities across different nodes without requiring a central authority.</p>
</li>
</ul>
<h2 id="intrinsic-vs-extrinsic-identifiers"><a class="header" href="#intrinsic-vs-extrinsic-identifiers">Intrinsic vs. Extrinsic Identifiers</a></h2>
<ul>
<li>
<p><strong>Intrinsic Identifiers (e.g., hashes, signatures)</strong><br />
These identifiers provide intrinsic identity by acting as unique fingerprints of the exact content they represent.
Unlike abstract identifiers, intrinsic identifiers are directly tied to the data itself, ensuring immutability
and self-validation.</p>
<p>Intrinsic identifiers are generated by applying cryptographic functions to the content. Their entropy requirements
are higher than those of abstract identifiers, as they must not only prevent accidental collisions but also
withstand adversarial scenarios, such as deliberate attempts to forge data.</p>
</li>
<li>
<p><strong>Extrinsic Identifiers (e.g., human-readable names, URLs, DOIs, UUIDs, UFOIDs, FUCIDs)</strong>
These identifiers provide identity that is not tied to the content itself,
but only by association. They are used to reference entities in a system, but do not
provide any guarantees about the content or the entity itself.
Allowing for continuity even as that entity may change or evolve.</p>
</li>
</ul>
<p>Extrinsic identifiers and intrinsic identifiers represent different kinds of metaphysical identity.<br />
For example, in the ship of Theseus thought experiment, both the original ship and the reconstructed ship<br />
would share the same extrinsic identity but have different intrinsic identities.</p>
<h2 id="embeddings-as-semantic-intrinsic-identifiers"><a class="header" href="#embeddings-as-semantic-intrinsic-identifiers">Embeddings as Semantic Intrinsic Identifiers</a></h2>
<p>Note that embeddings are the somewhat curious case of semantic intrinsic identifiers.
They are intrinsic in that they are tied to the content they represent, but they are also semantic in that they
carry meaning about the content. Embeddings are used to represent the content of an entity in a way that can be
compared to other entities, such as for similarity search or classification.
This makes them especially interesting for search and retrieval systems, where they can be used to find similar
entities based on a reference entity. But less useful for identity, as they are not necessarily unique.</p>
<p>One thing that makes them especially interesting is that they can be used to compare entities across different
systems or contexts, even if the entities themselves are not directly comparable. For example, you could compare
the embeddings of a text document and an image to find similar content, even though the two entities are of
different types.</p>
<p>Furthermore they aid in the decentralization and commoditization of search and retrieval systems, as they allow
for the relatively expensive process of generating embeddings to be done decoupled from the indexing and retrieval
process. This allows for the embedding generation to be done once in a distributed manner, and then the embeddings
can be used by any system that needs to compare entities. With the embeddings acting as a common language for
comparing entities, different embeddings can be compared without needing to know about the specifics of each system.</p>
<p>Contrastingly classic search and retrieval systems require a central authority to index and search the content,
as the indexing process is tightly coupled with the indexed data. This makes it difficult to compare entities
across different systems, as each system has its own index and retrieval process.
It also makes merging indexes virtually impossible, as the indexes are tightly coupled with the structure of the data they index.</p>
<h2 id="high-entropy-identifiers"><a class="header" href="#high-entropy-identifiers">High-Entropy Identifiers</a></h2>
<p>For a truly distributed system, the creation of identifiers must avoid the bottlenecks and overhead associated
with a central coordinating authority. At the same time, we must ensure that these identifiers are unique.</p>
<p>To guarantee uniqueness, we use abstract identifiers containing a large amount of entropy, making collisions
statistically irrelevant. However, the entropy requirements differ based on the type of identifier:</p>
<ul>
<li><strong>Extrinsic abstract identifiers</strong> need enough entropy to prevent accidental collisions in normal operation.</li>
<li><strong>Intrinsic abstract identifiers</strong> must also resist adversarial forging attempts, requiring significantly higher entropy.</li>
</ul>
<p>From an information-theoretic perspective, the length of an identifier determines the maximum amount of
entropy it can encode. For example, a 128-bit identifier can represent ( 2^{128} ) unique values, which is
sufficient to make collisions statistically negligible even for large-scale systems.</p>
<p>For intrinsic identifiers, 256 bits is widely considered sufficient when modern cryptographic hash functions
(e.g., SHA-256) are used. These hash functions provide strong guarantees of collision resistance, preimage
resistance, and second-preimage resistance. Even in the event of weaknesses being discovered in a specific
algorithm, it is more practical to adopt a new hash function than to increase the bit size of identifiers.</p>
<p>Additionally, future advances such as quantum computing are unlikely to undermine this length. Grover's algorithm
would halve the effective security of a 256-bit hash, reducing it to ( 2^{128} ) operations—still infeasible with
current or theoretical technology. As a result, 256 bits remains a future-proof choice for intrinsic identifiers.</p>
<p>Such 256-bit intrinsic identifiers are represented by the types
<a href="crate::value::schemas::hash::Hash"><code>tribles::value::schemas::hash::Hash</code></a> and
<a href="crate::value::schemas::hash::Handle"><code>tribles::value::schemas::hash::Handle</code></a>.</p>
<p>Additionally, we define three types of high-entropy abstract identifiers to address different requirements:<br />
<strong>RNGID, UFOID, and FUCID.</strong> Each balances trade-offs between entropy, locality, compression, and
predictability, as summarized below.</p>
<h2 id="comparison-of-identifier-types"><a class="header" href="#comparison-of-identifier-types">Comparison of Identifier Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="rngid::rngid">RNGID</a></th><th><a href="ufoid::ufoid">UFOID</a></th><th><a href="fucid::fucid">FUCID</a></th></tr></thead><tbody>
<tr><td>Entropy</td><td>High</td><td>High</td><td>Low</td></tr>
<tr><td>Locality</td><td>None</td><td>High</td><td>High</td></tr>
<tr><td>Compression</td><td>None</td><td>Low</td><td>High</td></tr>
<tr><td>Predictability</td><td>None</td><td>Low</td><td>Mid</td></tr>
</tbody></table>
</div>
<h1 id="example-scientific-publishing"><a class="header" href="#example-scientific-publishing">Example: Scientific Publishing</a></h1>
<p>Consider the case of published scientific papers. Each artifact, such as a <code>.html</code> or <code>.pdf</code> file,
should be identified by its abstract intrinsic identifier, typically a cryptographic hash of its content.
This ensures that any two entities referencing the same hash are referring to the exact same version
of the artifact, providing immutability and validation.</p>
<p>Across different versions of the same paper, an abstract extrinsic identifier can be used to tie these
artifacts together as part of one logical entity. The identifier provides continuity,
regardless of changes to the paper’s content over time.</p>
<p>Semantic (human-readable) identifiers, such as abbreviations in citations or bibliographies, are scoped to
individual papers and provide context-specific usability for readers. These names do not convey
identity but serve as a way for humans to reference the persistent abstract identifiers that underlie the system.</p>
<p>Sadly the identifiers used in practice, such as DOIs, fail to align with these principles and strengths.
They attempt to provide global extrinsic semantic identifiers for scientific papers,
an ultimately flawed approach. They lack the associated guarantees of intrinsic identifiers
and bring all the challenges of semantic identifiers. With their scope defined too broadly,
and their authority centralized, they fail to live up to the potential of distributed systems.</p>
<h1 id="id-ownership"><a class="header" href="#id-ownership">ID Ownership</a></h1>
<p>In distributed systems, consistency requires monotonicity due to the CALM principle.
However, this is not necessary for single writer systems. By assigning each ID an owner,
we ensure that only the current owner can write new information about an entity associated
with that ID. This allows for fine-grained synchronization and concurrency control.</p>
<p>To create a transaction, you can uniquely own all entities involved and write new data for them
simultaneously. Since there can only be one owner for each ID at any given time, you can be
confident that no other information has been written about the entities in question.</p>
<p>By default, all minted <code>ExclusiveId</code>s are associated with the thread they are dropped from.
These IDs can be found in queries via the <code>local_ids</code> function.</p>
<h2 id="ownership-and-eventual-consistency"><a class="header" href="#ownership-and-eventual-consistency">Ownership and Eventual Consistency</a></h2>
<p>While a simple grow set like the history stored in a <a href="crate::remote::Head">Head</a>
already constitutes a conflict-free replicated data type (CRDT), it is also limited in expressiveness.
To provide richer semantics while guaranteeing conflict-free mergeability we allow only
"owned" IDs to be used in the <code>entity</code> position of newly generated triples.
As owned IDs are [Send] but not [Sync] owning a
set of them essentially constitutes a single writer transaction domain,
allowing for some non-monotonic operations like <code>if-does-not-exist</code>, over
the set of contained entities. Note that this does not make operations that
would break CALM (consistency as logical monotonicity) safe, e.g. <code>delete</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../deep-dive/philosophy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../deep-dive/trible-structure.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../deep-dive/philosophy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../deep-dive/trible-structure.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
