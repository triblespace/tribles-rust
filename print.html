<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tribles Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A guided tour of Trible Space and how to use the crate.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tribles Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <strong>Tribles Book</strong>. This guide provides a gentle introduction to
Trible Space, its design goals and how to use the <code>tribles</code> crate.  The aim is to
present a clear narrative for newcomers while linking to in‑depth reference
material for those who want to dig deeper.</p>
<p>Trible Space combines ideas from databases and version control. Data is stored
in small immutable blobs that can live in memory, on disk or inside remote
object stores without conversion. Cryptographic identifiers ensure integrity and
enable efficient sharing across systems.</p>
<p>While this book walks you through the basics, the crate documentation offers a
complete API reference. Use the links throughout the text to jump directly to
the modules that interest you.</p>
<p>If you would like to work on Tribles yourself, check out <a href="contributing.html">Developing Locally</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>First add the crate to your project:</p>
<pre><code class="language-bash">cargo add tribles
</code></pre>
<p>Next create a simple repository and commit some data:</p>
<pre><code class="language-rust ignore">use tribles::prelude::*;
use tribles::examples::literature;
use tribles::repo::Repository;
use std::path::Path;
use ed25519_dalek::SigningKey;
use rand::rngs::OsRng;

const MAX_PILE_SIZE: usize = 1 &lt;&lt; 20;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let pile: Pile&lt;MAX_PILE_SIZE&gt; = Pile::open(Path::new("example.pile"))?;
    let mut repo = Repository::new(pile, SigningKey::generate(&amp;mut OsRng));
    let mut ws = repo.branch("main")?;

    ws.commit(literature::entity!(&amp;ufoid(), { firstname: "Alice" }), None);
    repo.push(&amp;mut ws)?;
    Ok(())
}</code></pre>
<p>See the <a href="https://docs.rs/tribles/latest/tribles/">crate documentation</a> for
additional modules and examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-locally"><a class="header" href="#developing-locally">Developing Locally</a></h1>
<p>To build and test Tribles yourself you need a recent Rust toolchain. Install it from <a href="https://rustup.rs/">rustup.rs</a>.</p>
<p>Run <code>./scripts/preflight.sh</code> from the repository root to format the code and execute the full test suite. For quick iterations <code>./scripts/devtest.sh</code> runs only the tests.</p>
<p>If you want to render this book locally first install <code>mdbook</code> with <code>cargo install mdbook</code> and then run <code>./scripts/build_book.sh</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Trible Space consists of two layers.  At the core is <a href="https://docs.rs/tribles/latest/tribles/trible/struct.TribleSet.html"><code>TribleSet</code></a>, an in‑memory data structure that behaves much like a hashmap.  It is cheap to create and merge and can be used on its own when durability is not required.  The optional repository layer stores those trible sets as blobs and links them through commits so that data can be exchanged and shared across machines.</p>
<p>The sections below outline how <a href="https://docs.rs/tribles/latest/tribles/repo/index.html"><code>tribles::repo</code></a> combines blob and branch stores into repositories and workspaces.</p>
<h2 id="trible-sets"><a class="header" href="#trible-sets">Trible Sets</a></h2>
<p><a href="https://docs.rs/tribles/latest/tribles/trible/struct.Trible.html"><code>Trible</code></a> values are stored in <code>TribleSet</code>s that function much like keyed hashmaps. They provide efficient querying and merging without any external storage. When you want to persist or exchange a set, it can be serialized into a blob and tracked by the repository layer.</p>
<h2 id="blob-storage"><a class="header" href="#blob-storage">Blob Storage</a></h2>
<p>Every byte of data is placed in a <a href="https://docs.rs/tribles/latest/tribles/blob/index.html"><code>BlobStore</code></a>.  The trait abstracts the backing implementation so the same code works with an in‑memory <a href="https://docs.rs/tribles/latest/tribles/blob/struct.MemoryBlobStore.html"><code>MemoryBlobStore</code></a>, an on‑disk <a href="https://docs.rs/tribles/latest/tribles/repo/pile/struct.Pile.html"><code>Pile</code></a> or a remote object store.  Trible sets, commit records and arbitrary user blobs are all inserted via <code>put</code> and addressed by their hash.</p>
<h2 id="branch-store"><a class="header" href="#branch-store">Branch Store</a></h2>
<p>Repositories keep track of branch heads in a <a href="https://docs.rs/tribles/latest/tribles/repo/trait.BranchStore.html"><code>BranchStore</code></a>.  The store maps branch identifiers to the latest commit and uses a simple compare‑and‑set update to avoid conflicts.  Pile and the in‑memory repo both provide branch store implementations.</p>
<h2 id="repository"><a class="header" href="#repository">Repository</a></h2>
<p>The <a href="https://docs.rs/tribles/latest/tribles/repo/struct.Repository.html"><code>Repository</code></a> combines a blob store with a branch store and exposes higher level operations similar to a remote Git repository.  Commits reference blobs holding the changed <a href="https://docs.rs/tribles/latest/tribles/trible/struct.TribleSet.html"><code>TribleSet</code></a> and optionally point to a parent commit.</p>
<h2 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h2>
<p>A <a href="https://docs.rs/tribles/latest/tribles/repo/struct.Workspace.html"><code>Workspace</code></a> represents mutable state during editing.  When you <code>branch</code> or <code>checkout</code> you receive a workspace with a fresh <a href="https://docs.rs/tribles/latest/tribles/blob/struct.MemoryBlobStore.html"><code>MemoryBlobStore</code></a> for new blobs.  Commits created in the workspace are stored locally until <code>push</code> updates the repository's branch store.  Multiple workspaces can be merged before pushing to resolve conflicts.</p>
<h2 id="commits-and-history"><a class="header" href="#commits-and-history">Commits and History</a></h2>
<p><a href="https://docs.rs/tribles/latest/tribles/trible/struct.Trible.html"><code>Trible</code></a> is the smallest unit of information. <code>TribleSet</code>s can be written to a blob and committed to create an immutable history.  Each commit links to the previous one and is signed by the author.  This chain forms the durable database layer that repositories expose.</p>
<h3 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h3>
<pre><code class="language-text">+-----------------------------------------------------------+
|                        Repository                          |
|   +---------------------+   +----------------------------+ |
|   |      BlobStore      |   |        BranchStore        | |
|   +---------------------+   +----------------------------+ |
+-----------------------------------------------------------+
           ^ checkout                            | push
           |                                     v
+-----------------------------------------------------------+
|                        Workspace                           |
|   +---------------------+   +----------------------------+ |
|   |   MemoryBlobStore   |   |          TribleSet        | |
|   +---------------------+   +----------------------------+ |
+-----------------------------------------------------------+
                      |
                      | commit/add_blob
                      v
                 TribleSet blobs
</code></pre>
<p>Repositories persist blobs and branch metadata, while workspaces stage changes before pushing them.  Because everything is content addressed, different repositories can easily share blobs through a common object store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deep-dive"><a class="header" href="#deep-dive">Deep Dive</a></h1>
<p>This section contains in-depth discussions about Trible Space internals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h1>
<p>This section collects the more detailed discussions around the design of
Trible Space and the reasoning behind certain choices. It is meant as an
optional read for the curious.</p>
<p>We prioritise a simple and predictable system over clever heuristics. Each
component should be understandable on its own and interact cleanly with the
rest of the stack.</p>
<p>Developer experience is equally important. APIs aim to be straightforward and
use synchronous building blocks that can be composed as needed.</p>
<p>Finally, we strive for soundness and performance. Safety checks guard against
invalid data while efficient data structures keep the core fast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers-for-distributed-systems"><a class="header" href="#identifiers-for-distributed-systems">Identifiers for Distributed Systems</a></h1>
<p>We found it useful to categorize identifiers along two axes:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Abstract</strong></th><th><strong>Semantic</strong></th></tr></thead><tbody>
<tr><td><strong>Intrinsic</strong></td><td>Hash, Signature, PubKey</td><td>embeddings</td></tr>
<tr><td><strong>Extrinsic</strong></td><td>UUID, UFOID, FUCID</td><td>names, DOI, URL</td></tr>
</tbody></table>
</div>
<h2 id="abstract-vs-semantic-identifiers"><a class="header" href="#abstract-vs-semantic-identifiers">Abstract vs. Semantic Identifiers</a></h2>
<ul>
<li>
<p><strong>Semantic Identifiers (e.g., human-readable names, URLs, embeddings)</strong>
These identifiers carry meaning and context about the entity they represent.
This can make them them useful for human users,
as they can convey information about the entity without requiring additional lookups.
For example, a URL can provide information about the location of a resource,
or a human readable name can provide information about the entity itself.
Embeddings are a special case of semantic identifiers,
as they represent the content of an entity in a way that can be compared to other entities.
They are also more likely to change over time, as the context of the entity changes.
This makes them less useful for identity, as they are not necessarily unique;
their strength is to aid interpretation rather than define persistence.
To avoid ambiguities and conflicts or the need for a central authority to manage them,
semantic identifiers should always be explicitly scoped to a context,
such as a namespace or system environment. This ensures that the
same name can coexist in different contexts without collision or confusion.
This scoping also addresses social challenges inherent in human-readable names:
different users may prefer different names for the same entity.
By allowing local names to reference persistent identifiers (extrinsic or intrinsic),
each user can adopt their preferred naming conventions while maintaining
a shared understanding of the underlying identity.</p>
</li>
<li>
<p><strong>Abstract Identifiers (e.g., UUIDs, UFOIDs, FUCIDs, hashes, signatures)</strong><br />
These identifiers provide abstract identity without imposing any semantic meaning or cultural connotations.
They can be generated cheaply and without coordination, relying on high entropy to make collisions
practically impossible, uniquely, globally, and persistently addressing an entity, regardless of its content or context.
Abstract identifiers, when used to reference entities in a system, provide a stable and unique identity that is
independent of the content or context of the entity. They are particularly useful in distributed systems, where
they can be used to address entities across different nodes without requiring a central authority.</p>
</li>
</ul>
<h2 id="intrinsic-vs-extrinsic-identifiers"><a class="header" href="#intrinsic-vs-extrinsic-identifiers">Intrinsic vs. Extrinsic Identifiers</a></h2>
<ul>
<li>
<p><strong>Intrinsic Identifiers (e.g., hashes, signatures)</strong><br />
These identifiers provide intrinsic identity by acting as unique fingerprints of the exact content they represent.
Unlike abstract identifiers, intrinsic identifiers are directly tied to the data itself, ensuring immutability
and self-validation.</p>
<p>Intrinsic identifiers are generated by applying cryptographic functions to the content. Their entropy requirements
are higher than those of abstract identifiers, as they must not only prevent accidental collisions but also
withstand adversarial scenarios, such as deliberate attempts to forge data.</p>
</li>
<li>
<p><strong>Extrinsic Identifiers (e.g., human-readable names, URLs, DOIs, UUIDs, UFOIDs, FUCIDs)</strong>
These identifiers provide identity that is not tied to the content itself,
but only by association. They are used to reference entities in a system, but do not
provide any guarantees about the content or the entity itself.
Allowing for continuity even as that entity may change or evolve.</p>
</li>
</ul>
<p>Extrinsic identifiers and intrinsic identifiers represent different kinds of metaphysical identity.<br />
For example, in the ship of Theseus thought experiment, both the original ship and the reconstructed ship<br />
would share the same extrinsic identity but have different intrinsic identities.</p>
<h2 id="embeddings-as-semantic-intrinsic-identifiers"><a class="header" href="#embeddings-as-semantic-intrinsic-identifiers">Embeddings as Semantic Intrinsic Identifiers</a></h2>
<p>Note that embeddings are the somewhat curious case of semantic intrinsic identifiers.
They are intrinsic in that they are tied to the content they represent, but they are also semantic in that they
carry meaning about the content. Embeddings are used to represent the content of an entity in a way that can be
compared to other entities, such as for similarity search or classification.
This makes them especially interesting for search and retrieval systems, where they can be used to find similar
entities based on a reference entity. But less useful for identity, as they are not necessarily unique.</p>
<p>One thing that makes them especially interesting is that they can be used to compare entities across different
systems or contexts, even if the entities themselves are not directly comparable. For example, you could compare
the embeddings of a text document and an image to find similar content, even though the two entities are of
different types.</p>
<p>Furthermore they aid in the decentralization and commoditization of search and retrieval systems, as they allow
for the relatively expensive process of generating embeddings to be done decoupled from the indexing and retrieval
process. This allows for the embedding generation to be done once in a distributed manner, and then the embeddings
can be used by any system that needs to compare entities. With the embeddings acting as a common language for
comparing entities, different embeddings can be compared without needing to know about the specifics of each system.</p>
<p>Contrastingly classic search and retrieval systems require a central authority to index and search the content,
as the indexing process is tightly coupled with the indexed data. This makes it difficult to compare entities
across different systems, as each system has its own index and retrieval process.
It also makes merging indexes virtually impossible, as the indexes are tightly coupled with the structure of the data they index.</p>
<h2 id="high-entropy-identifiers"><a class="header" href="#high-entropy-identifiers">High-Entropy Identifiers</a></h2>
<p>For a truly distributed system, the creation of identifiers must avoid the bottlenecks and overhead associated
with a central coordinating authority. At the same time, we must ensure that these identifiers are unique.</p>
<p>To guarantee uniqueness, we use abstract identifiers containing a large amount of entropy, making collisions
statistically irrelevant. However, the entropy requirements differ based on the type of identifier:</p>
<ul>
<li><strong>Extrinsic abstract identifiers</strong> need enough entropy to prevent accidental collisions in normal operation.</li>
<li><strong>Intrinsic abstract identifiers</strong> must also resist adversarial forging attempts, requiring significantly higher entropy.</li>
</ul>
<p>From an information-theoretic perspective, the length of an identifier determines the maximum amount of
entropy it can encode. For example, a 128-bit identifier can represent ( 2^{128} ) unique values, which is
sufficient to make collisions statistically negligible even for large-scale systems.</p>
<p>For intrinsic identifiers, 256 bits is widely considered sufficient when modern cryptographic hash functions
(e.g., SHA-256) are used. These hash functions provide strong guarantees of collision resistance, preimage
resistance, and second-preimage resistance. Even in the event of weaknesses being discovered in a specific
algorithm, it is more practical to adopt a new hash function than to increase the bit size of identifiers.</p>
<p>Additionally, future advances such as quantum computing are unlikely to undermine this length. Grover's algorithm
would halve the effective security of a 256-bit hash, reducing it to ( 2^{128} ) operations—still infeasible with
current or theoretical technology. As a result, 256 bits remains a future-proof choice for intrinsic identifiers.</p>
<p>Such 256-bit intrinsic identifiers are represented by the types
<a href="crate::value::schemas::hash::Hash"><code>tribles::value::schemas::hash::Hash</code></a> and
<a href="crate::value::schemas::hash::Handle"><code>tribles::value::schemas::hash::Handle</code></a>.</p>
<p>Additionally, we define three types of high-entropy abstract identifiers to address different requirements:<br />
<strong>RNGID, UFOID, and FUCID.</strong> Each balances trade-offs between entropy, locality, compression, and
predictability, as summarized below.</p>
<h2 id="comparison-of-identifier-types"><a class="header" href="#comparison-of-identifier-types">Comparison of Identifier Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="rngid::rngid">RNGID</a></th><th><a href="ufoid::ufoid">UFOID</a></th><th><a href="fucid::fucid">FUCID</a></th></tr></thead><tbody>
<tr><td>Entropy</td><td>High</td><td>High</td><td>Low</td></tr>
<tr><td>Locality</td><td>None</td><td>High</td><td>High</td></tr>
<tr><td>Compression</td><td>None</td><td>Low</td><td>High</td></tr>
<tr><td>Predictability</td><td>None</td><td>Low</td><td>Mid</td></tr>
</tbody></table>
</div>
<h1 id="example-scientific-publishing"><a class="header" href="#example-scientific-publishing">Example: Scientific Publishing</a></h1>
<p>Consider the case of published scientific papers. Each artifact, such as a <code>.html</code> or <code>.pdf</code> file,
should be identified by its abstract intrinsic identifier, typically a cryptographic hash of its content.
This ensures that any two entities referencing the same hash are referring to the exact same version
of the artifact, providing immutability and validation.</p>
<p>Across different versions of the same paper, an abstract extrinsic identifier can be used to tie these
artifacts together as part of one logical entity. The identifier provides continuity,
regardless of changes to the paper’s content over time.</p>
<p>Semantic (human-readable) identifiers, such as abbreviations in citations or bibliographies, are scoped to
individual papers and provide context-specific usability for readers. These names do not convey
identity but serve as a way for humans to reference the persistent abstract identifiers that underlie the system.</p>
<p>Sadly the identifiers used in practice, such as DOIs, fail to align with these principles and strengths.
They attempt to provide global extrinsic semantic identifiers for scientific papers,
an ultimately flawed approach. They lack the associated guarantees of intrinsic identifiers
and bring all the challenges of semantic identifiers. With their scope defined too broadly,
and their authority centralized, they fail to live up to the potential of distributed systems.</p>
<h1 id="id-ownership"><a class="header" href="#id-ownership">ID Ownership</a></h1>
<p>In distributed systems, consistency requires monotonicity due to the CALM principle.
However, this is not necessary for single writer systems. By assigning each ID an owner,
we ensure that only the current owner can write new information about an entity associated
with that ID. This allows for fine-grained synchronization and concurrency control.</p>
<p>To create a transaction, you can uniquely own all entities involved and write new data for them
simultaneously. Since there can only be one owner for each ID at any given time, you can be
confident that no other information has been written about the entities in question.</p>
<p>By default, all minted <code>ExclusiveId</code>s are associated with the thread they are dropped from.
These IDs can be found in queries via the <code>local_ids</code> function.</p>
<h2 id="ownership-and-eventual-consistency"><a class="header" href="#ownership-and-eventual-consistency">Ownership and Eventual Consistency</a></h2>
<p>While a simple grow set like the history stored in a <a href="crate::remote::Head">Head</a>
already constitutes a conflict-free replicated data type (CRDT), it is also limited in expressiveness.
To provide richer semantics while guaranteeing conflict-free mergeability we allow only
"owned" IDs to be used in the <code>entity</code> position of newly generated triples.
As owned IDs are [Send] but not [Sync] owning a
set of them essentially constitutes a single writer transaction domain,
allowing for some non-monotonic operations like <code>if-does-not-exist</code>, over
the set of contained entities. Note that this does not make operations that
would break CALM (consistency as logical monotonicity) safe, e.g. <code>delete</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The <code>trible</code> module contains the definition of the <code>Trible</code> struct, which is the fundamental unit of knowledge in the knowledge graph.
Instance of <code>Trible</code>s are stored in <code>TribleSet</code>s which index the trible in various ways, allowing for efficient querying and retrieval of data.</p>
<pre><code class="language-text">┌────────────────────────────64 byte───────────────────────────┐
┌──────────────┐┌──────────────┐┌──────────────────────────────┐
│  entity-id   ││ attribute-id ││        inlined value         │
└──────────────┘└──────────────┘└──────────────────────────────┘
└────16 byte───┘└────16 byte───┘└────────────32 byte───────────┘
─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─▶
</code></pre>
<h1 id="direction-and-consistency"><a class="header" href="#direction-and-consistency">Direction and Consistency</a></h1>
<p>In other triple stores the direction of the edge drawn by a triple is often
choosen incidentally, e.g. there is no intrinsic preference for <code>hasColor</code> over
<code>colorOf</code>. This can lead to confusion and inconsistency in the graph, as
different writers might choose different directions for the same edge.
This is typically solved by:</p>
<ul>
<li>Automatically inferring the opposite edge for every edge inserted,
as done by OWL and RDF with the <code>inverseOf</code> predicate. Leading to a
doubling of the number of edges in the graph or inference at query time.</li>
<li>Endless bikeshedding about the "right" direction of edges.</li>
</ul>
<p>In the <code>tribles</code> crate we solve this problem by giving the direction of the edge
an explicit semantic meaning: The direction of the edge indicates which entity
is the one making the statement, i.e. which entity is observing the fact
or proclaiming the relationship. This is a simple and consistent rule that
naturally fits into a distributed system, where each entity is associated with
a single writer that is responsible the consistency of the facts it asserts.</p>
<ul>
<li>see <a href="crate::id">ID Ownership</a>.</li>
</ul>
<p>A different perspective is that edges are always ordered from describing
to described entities, with circles constituting consensus between them.</p>
<p>For example, the edge <code>hasColor</code> is always drawn from the entity that has
the color to the entity that represents the color. This makes the direction
of the edge a natural consequence of the semantics of the edge, and not
an arbitrary choice.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
